
//Конкурсная программа — Поиск оптимального пути в лабиринте.
//Автор: Исакова Маргарита, группа 13501/1.

//Метод выполнения: алгоритм Ли (волновой алгоритм) + метод ближайшего соседа. 
//К точке выхода идём в самом конце, после сбора всех доступных бонусов.

//Данный метод не является самым оптимальным из возможных, 
	//избран по причине нехватки времени на выполнение задания другими, более оптимальными методами.
	//(изначально было задумано дерево путей + поиск в глубину самого короткого пути + 
	//проверка рациональности собирания приза).


#include <iostream>
#include <string>
#include <fstream>
#include <conio.h>

using namespace std;

void Open_File (string name, fstream& flow);//Функция для открытия файла ввода
void Read_Map(fstream& flow, char**& map, int& rows, int& cols);//Функция для чтения файла ввода и создания 
																//карты лабиритна (двумерный массив типа char)
//Функция для создания рабочей карты (двумерный массив типа int)
void Create_Work_Map(char** map,int**& map_w, int rows, int cols, int& x, int& y, int& x_exit, int& y_exit);
//Функция для посчёта количества доступных (незамурованных) призов на карте
void Num_Of_Available_Bonuses (int**& map_temp, int rows, int cols, int& x, int& y, int &num_bon);
//Функция нахождения пути от одной клетки к другой + пишет в консоли пройденный путь (l, r, u, d)
void Route_Cycle (int**& map_w, int rows, int cols, int& x, int& y);

int main(int argc, char *args[])
{
	setlocale (LC_CTYPE, ".1251");//Для правильного вывода русского языка в консоли
	setlocale (LC_MONETARY, ".1251");
	
	fstream fin;//Переменная для работы с входным файлом
	char** map = 0;//Символьная карта, идентичная карте в файле ввода 
				   //(можно работать и без неё, считывая информацию напрямую из файла ввода, но с ней код читабельней)
				   //(+ при желании, её всегда можно легко вывести в консоль)
	int** map_w = 0;//Основная рабочая карта
	int** map_temp = 0;//Временная рабочая карта 
	
	int rows = 0;//Количество строк в карте
	int cols = 0;//Количество столбцов
	int x = 0;//Вспомогательные переменные для хранения временных координат
	int y = 0;
	int num_bon = 0;//Количество доступных призов

	int x_exit;//Переменные для хранения координат клетки выхода
	int y_exit;
	
	if( argc == 1)
	{
		cout << "аргументы не заданы\n";
		_getch();
		return 0;
	}
	else
		cout << "работаем с файлом " << args[1] << endl <<endl;

	string input (args[1]);//Название файла ввода записываем в строку
	
	Open_File(input, fin);//Открыли файл ввода
	Read_Map(fin, map, rows, cols);//Записали карту

	fin.close();//Закрыли файл ввода

	Create_Work_Map(map, map_w, rows, cols, x, y, x_exit, y_exit);

	//Создаём временную рабочуу карту, идентичную основной рабочей карте.
	map_temp = new int*[rows];
	for (int i = 0; i< rows; i++)
		map_temp[i] = new int[cols];

	for (int i = 0; i<rows; i++)
	{
		for (int j = 0; j<cols; j++)
		{
			map_temp[i][j] = map_w[i][j];
		}
	}

	//По временной рабочей карте ищем количество доступных бонусов
	Num_Of_Available_Bonuses (map_temp, rows, cols, x,  y, num_bon);
	
	//Удалим map_temp
	for (int i=0; i<rows; i++)
	{
		delete []map_temp[i];
	}
	delete []map_temp;


	while(num_bon != 0)//Пока ещё остались невзятые бонусы
	{
		Route_Cycle (map_w, rows, cols, x, y);
		num_bon--;//Декрементируем количество бонусов
	}
	//Теперь идём к выходу
	
	map_w[x_exit][y_exit] = -2;//Помечаем клетку выхода на рабочей карте
	Route_Cycle (map_w, rows, cols, x, y);
	
	//удалить символьную и рабочую карту
	for (int i=0; i<rows; i++)
	{
		delete []map_w[i];
		delete []map[i];
	}
	delete []map_w;
	delete []map;
	
	_getch();
}

void Open_File (string name, fstream& flow)
{
	flow.open(name.c_str(), ios::in);
	if(!flow)
	{
		cout << "Ошибка №1: файл "<< name <<" не найден.\n";
		_getch();
	}
}

void Read_Map (fstream& flow, char**& map, int& rows, int& cols)
{
	char c = '#';//Вспомогательная переменная
	string stroka;//Вспомогательная переменная
	int ha = 0;//Для хранения количество встречающихся подряд # в одной строчке
	int iter = 2;//Вспомогательная переменная для подсчёта rows. Равна 2, т.к. подсчёт rows будем вести со 2-ой строки.

	flow >> ws;//Пропустили все пустые символы

	for ( ;c == '#'; flow.get(c))
		cols++;//Сколько в строчке #, таким и будет количество столбцов в нашей карте
	
	//т.к. изначально "с" была равна #, то cols посчитали на один больше
	cols--;
	
	for ( ; rows == 0; )//Пока количество строк не подсчитано
	{
		flow.get(c);
		if (c == '#')
		{
			ha++;//Количество встречающихся подряд # в одной строчке
			if (ha == cols)//Если все символы в строке равны #
			{
				rows = iter;
				break;
			}
			else
				continue;
		}
		else
		{
			ha = 0;
			iter++;//Количество пройденых строк инкрементировалось
			getline(flow, stroka);//Считываем все остальные символы строки, переходим на новую строку.
								  //Нужно на случай, если после правой границы карты стоят ещё какие-нибудь символы.
								  //(много искала, но более удобного перехода на новую строку не нашла.)
			continue;
		}
	}

	map = new char*[rows];
	for (int i = 0; i< rows; i++)
		map[i] = new char[cols];

	flow.clear();//т.к. дошли до конца файла, обнулим флаги для дальнейшей работы с файлом
	flow.seekg(0);// Возвращаемся в начало файла
	flow >> ws;

	for (int i = 0; i < rows; i++)
	{
		for (int j = 0; j < cols; j++)
			flow.get(map[i][j]);
		getline(flow, stroka);//Переходим на новую строку.
	}
}

void Create_Work_Map(char** map,int**& map_w, int rows, int cols, int& x, int& y, int& x_exit, int& y_exit)
{
	map_w = new int*[rows];//Создаём карту, с которой нам будет удобно работать.
	for (int i = 0; i< rows; i++)
		map_w[i] = new int[cols];

	for (int i = 0; i<rows; i++)
	{
		for (int j = 0; j<cols; j++)
		{
			if (map[i][j] == '*')
			{
				map_w[i][j] = 1;//Так на рабочей карте помечаем клетку "входа"
			}
			else if (map[i][j] == '#')
				map_w[i][j] = -1;//Так на рабочей карте помечаем клетку "стены"
			else if ((map[i][j]>='1') && (map[i][j]<='9'))
			{
				map_w[i][j] = -2;//Так на рабочей карте помечаем клетку "приза"
			}
			else if (map[i][j] == 'e')
			{
				x_exit = i;//Записали координаты выхода в предназначенные для этого переменные
				y_exit = j;
				map_w[i][j] = 0;//Клетку выхода ничем не помечаем, т.к. по алгоритму пойдём к нему в последнюю очередь
			}
			else
				map_w[i][j] = 0;//Так на рабочей карте помечаем свободные для прохода клетки 
		}
	}
}

void Num_Of_Available_Bonuses (int**& map_temp, int rows, int cols, int& x, int& y, int &num_bon)
{
	//Чтобы найти все "незамурованные" бонусы проходим пошагово всю карту начиная с клетки входа. 
	//Если натолкнулись на приз, то инкрементируем num_bon
	//Метод работы функции: алгоритм Ли (волновой алгоритм)
	
	int z = 1;//считает "шаги", проделанные от клетки входа
	int f = 1;//для подсчёта количества "клеток остановок", найденных за итерацию цикла while, 
			  //изначально равен 1 чтобы зайти в цикл while (там обнуляется)
	int nac = 1;//кол-во клеток отправления для каждой итерации (сначала только одна, стартовая, потом по ситуации)


	while (f != 0)
	{
		if (nac == 0)//Если обработаны все клетки отправления
		{	
			nac = f;//Клетки отправления равны количеству найдённых ранее "клеток остановок"
			z++;
		}

		f = 0;//Обнулили клетки остановок

		for (int i = 1; (i<rows)&&(nac!=0); i++)
		{
			for (int j = 1; (j<cols)&&(nac!=0); j++)
			{
				if (map_temp[i][j] == z)//нашли клетку отправления
				{
					nac--;//Клеток отправления стало на одну меньше (т.к. только что нашли одну)
					if ((map_temp[i+1][j] == 0)||(map_temp[i+1][j] == -2))
					{
						if (map_temp[i+1][j] == -2)//Если клетка содержит приз
							num_bon++;
						map_temp[i+1][j] = z+1;
						f++;//Клеток остановок стало на одну больше
					}
					if ((map_temp[i-1][j] == 0)||(map_temp[i-1][j] == -2))
					{
						if (map_temp[i-1][j] == -2)
							num_bon++;
						map_temp[i-1][j] = z+1;
						f++;
					}
					if ((map_temp[i][j+1] == 0)||(map_temp[i][j+1] == -2))
					{
						if (map_temp[i][j+1] == -2)
							num_bon++;
						map_temp[i][j+1] = z+1;
						f++;
					}
					if ((map_temp[i][j-1] == 0)||(map_temp[i][j-1] == -2))
					{
						if (map_temp[i][j-1] == -2)
							num_bon++;
						map_temp[i][j-1] = z+1;
						f++;
					}
				}
			}
		}
	}
}

void Route_Cycle (int**& map_w, int rows, int cols, int& x, int& y)
{
	//Идём от точки к точке методом ближайшего соседа.
	//Метод работы функции: алгоритм Ли (волновой алгоритм)
	
	int z = 1;//считает "шаги", проделанные от клетки входа
	bool found = 0;//нашли ли бонус
	int f = 0;//кол-во найденных клеток остановок
	int nac = 1;//кол-во клеток отправления для каждой итерации (сначала только одна, стартовая, потом по ситуации)

	//Алгоритмом Ли проверяем вправо, влево, вних и вверх от клетки, если путь свободен. 
	//Если свободен, присваиваем соответствующей клетке на рабочей карте значение z+1
	//Если клетка не свободна и на ней расположен бонус, то помечаем эту клетку значением -8
	//Вход обозначен = 1, т.е. = z. С этой точки и начинаем.
	
	while (!found)//пока не нашли приз
	{
		if (nac == 0)//Если проверили все клетки отправления
		{	
			nac = f;//Кол-во клеток отправления = кол-ву клеток остановки
			z++;
		}
		for (int i = 1; (i<rows)&&(nac!=0); i++)
		{
			for (int j = 1; (j<cols)&&(nac!=0); j++)
			{
				if (map_w[i][j] == z)//Нашли клетку отправления
				{
					nac--;//Декрементировали кол-во клеток отправления
					if (map_w[i+1][j] == 0)// Если соседняя клетка является пустой от стен и знаков
					{
						map_w[i+1][j] = z+1;
						f++;//Добавили клетку остановки
					}
					else if (map_w[i+1][j] == -2)//Если же она содержит приз
					{
						map_w[i+1][j] = -8;
						x = i+1;//Записываем её координаты
						y = j;
						found = 1;//Нашли приз
						break;//Вышли из цикла 
					}
					if (map_w[i-1][j] == 0)
					{
						map_w[i-1][j] = z+1;
						f++;
					}
					else if (map_w[i-1][j] == -2)
					{
						map_w[i-1][j] = -8;
						x = i-1;
						y = j;
						found = 1;
						break;
					}
					if (map_w[i][j+1] == 0)
					{
						map_w[i][j+1] = z+1;
						f++;
					}
					else if (map_w[i][j+1] == -2)
					{
						map_w[i][j+1] = -8;
						x = i;
						y = j+1;
						found = 1;
						break;
					}
					if (map_w[i][j-1] == 0)
					{
						map_w[i][j-1] = z+1;
						f++;
					}
					else if (map_w[i][j-1] == -2)
					{
						map_w[i][j-1] = -8;
						x = i;
						y = j-1;
						found = 1;
						break;
					}
				}
			}
		}
	}
	
	//Теперь идём обратно от найденного приза к стартовой точке, весь путь помечая значением -9

	for( ; z>0; z--)
	{
		if (map_w[x+1][y] == z)
		{
			map_w[x+1][y] = -9;
			x++;
		}
		if (map_w[x-1][y] == z)
		{
			map_w[x-1][y] = -9;
			x--;
		}
		if (map_w[x][y+1] == z)
		{
			map_w[x][y+1] = -9;
			y++;
		}
		if (map_w[x][y-1] == z)
		{
			map_w[x][y-1] = -9;
			y--;
		}
	}


	//Теперь опять идём из начальной точки в конечную (просматривая, в какой из соседних клеток значение = -9)
	//И выводим в консоль путь: l, r, u, d

	while (map_w[x][y] != -8) //пока не дошли до конечной точки
	{
		if ((map_w[x+1][y] == -9)||(map_w[x+1][y] == -8))// если эта клетка является клеткой пути
		{
			cout << "d";//Обозначение для найденного пути
			map_w[x][y] = 0;//Обнуляем значение этой клетки
			x++;
			continue;
		}

		if ((map_w[x-1][y] == -9)||(map_w[x-1][y] == -8))
		{
			cout << "u";
			map_w[x][y] = 0;
			x--;
			continue;
		}
		if ((map_w[x][y+1] == -9)||(map_w[x][y+1] == -8))
		{
			cout << "r";
			map_w[x][y] = 0; 
			y++;
			continue;
		}
		if ((map_w[x][y-1] == -9)||(map_w[x][y-1] == -8))
		{
			cout << "l";
			map_w[x][y] = 0;
			y--;
			continue;
		}
	}
	
	for (int i = 0; i< rows; i++)
	{
		for (int j = 0; j < cols; j++)
		{
			if (map_w[i][j] > 0)//Обнулили все шажки, сделанные в цикле волнового алгоритма
				map_w[i][j] = 0;
			else if (map_w[i][j] == -8)//Значение других найденных бонусов, если такие были, сделали равным -2 
				//(нужно делать для случая, если нашлось несколько бонусов на одинаковом расстоянии от клетки отправения)
				map_w[i][j] = -2;
		}
	}
	map_w[x][y] = 1;//Бонус, к которому пришли, пометили как точку отправления (для последующих циклов)
}
	

